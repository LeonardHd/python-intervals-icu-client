# coding: utf-8

"""
    Intervals.icu API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from intervals_icu_client.models.activity_charts import ActivityCharts
from intervals_icu_client.models.display import Display
from intervals_icu_client.models.power_model import PowerModel
from typing import Optional, Set
from typing_extensions import Self

class SportSettings(BaseModel):
    """
    SportSettings
    """ # noqa: E501
    id: Optional[StrictInt] = None
    athlete_id: Optional[StrictStr] = None
    types: Optional[List[StrictStr]] = None
    warmup_time: Optional[StrictInt] = None
    cooldown_time: Optional[StrictInt] = None
    ftp: Optional[StrictInt] = None
    indoor_ftp: Optional[StrictInt] = None
    w_prime: Optional[StrictInt] = None
    p_max: Optional[StrictInt] = None
    power_zones: Optional[List[StrictInt]] = None
    sweet_spot_min: Optional[StrictInt] = None
    sweet_spot_max: Optional[StrictInt] = None
    power_spike_threshold: Optional[StrictInt] = None
    power_zone_names: Optional[List[StrictStr]] = None
    ftp_est_min_secs: Optional[StrictInt] = None
    use_laps_for_power_intervals: Optional[StrictBool] = None
    keep_all_laps_for_power_intervals: Optional[StrictBool] = None
    after_kj0: Optional[StrictInt] = None
    after_kj1: Optional[StrictInt] = None
    power_field: Optional[StrictStr] = None
    lthr: Optional[StrictInt] = None
    max_hr: Optional[StrictInt] = None
    hr_zones: Optional[List[StrictInt]] = None
    hr_zone_names: Optional[List[StrictStr]] = None
    hr_load_type: Optional[StrictStr] = None
    hrrc_min_percent: Optional[Union[StrictFloat, StrictInt]] = None
    threshold_pace: Optional[Union[StrictFloat, StrictInt]] = None
    pace_units: Optional[StrictStr] = None
    pace_zones: Optional[List[Union[StrictFloat, StrictInt]]] = None
    pace_zone_names: Optional[List[StrictStr]] = None
    pace_load_type: Optional[StrictStr] = None
    gap_model: Optional[StrictStr] = None
    elevation_correction: Optional[StrictStr] = None
    use_gap_zone_times: Optional[StrictBool] = None
    best_effort_distances: Optional[List[Union[StrictFloat, StrictInt]]] = None
    pace_curve_start: Optional[Union[StrictFloat, StrictInt]] = None
    load_order: Optional[StrictStr] = None
    tiz_order: Optional[StrictStr] = None
    workout_order: Optional[StrictStr] = None
    interval_display: Optional[StrictStr] = None
    default_gear_id: Optional[StrictStr] = None
    default_indoor_gear_id: Optional[StrictStr] = None
    extract_workouts: Optional[StrictBool] = None
    show_pauses: Optional[StrictInt] = None
    ignore_velocity: Optional[StrictBool] = None
    default_workout_time: Optional[StrictStr] = None
    created: Optional[datetime] = None
    updated: Optional[datetime] = None
    mmp_model: Optional[PowerModel] = None
    display: Optional[Display] = None
    activity_field_ids: Optional[List[StrictInt]] = None
    activity_charts: Optional[ActivityCharts] = None
    custom_field_ids: Optional[List[StrictInt]] = None
    custom_field_values: Optional[Dict[str, Dict[str, Any]]] = None
    custom_zones_ids: Optional[List[StrictInt]] = None
    other: Optional[StrictBool] = None
    ise_ftp_supported: Optional[StrictBool] = Field(default=None, alias="iseFTPSupported")
    use_distance_for_intervals: Optional[StrictBool] = None
    __properties: ClassVar[List[str]] = ["id", "athlete_id", "types", "warmup_time", "cooldown_time", "ftp", "indoor_ftp", "w_prime", "p_max", "power_zones", "sweet_spot_min", "sweet_spot_max", "power_spike_threshold", "power_zone_names", "ftp_est_min_secs", "use_laps_for_power_intervals", "keep_all_laps_for_power_intervals", "after_kj0", "after_kj1", "power_field", "lthr", "max_hr", "hr_zones", "hr_zone_names", "hr_load_type", "hrrc_min_percent", "threshold_pace", "pace_units", "pace_zones", "pace_zone_names", "pace_load_type", "gap_model", "elevation_correction", "use_gap_zone_times", "best_effort_distances", "pace_curve_start", "load_order", "tiz_order", "workout_order", "interval_display", "default_gear_id", "default_indoor_gear_id", "extract_workouts", "show_pauses", "ignore_velocity", "default_workout_time", "created", "updated", "mmp_model", "display", "activity_field_ids", "activity_charts", "custom_field_ids", "custom_field_values", "custom_zones_ids", "other", "iseFTPSupported", "use_distance_for_intervals"]

    @field_validator('types')
    def types_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Ride', 'Run', 'Swim', 'WeightTraining', 'Hike', 'Walk', 'AlpineSki', 'BackcountrySki', 'Badminton', 'Canoeing', 'Crossfit', 'EBikeRide', 'EMountainBikeRide', 'Elliptical', 'Golf', 'GravelRide', 'TrackRide', 'Handcycle', 'HighIntensityIntervalTraining', 'Hockey', 'IceSkate', 'InlineSkate', 'Kayaking', 'Kitesurf', 'MountainBikeRide', 'NordicSki', 'OpenWaterSwim', 'Padel', 'Pilates', 'Pickleball', 'Racquetball', 'Rugby', 'RockClimbing', 'RollerSki', 'Rowing', 'Sail', 'Skateboard', 'Snowboard', 'Snowshoe', 'Soccer', 'Squash', 'StairStepper', 'StandUpPaddling', 'Surfing', 'TableTennis', 'Tennis', 'TrailRun', 'Transition', 'Velomobile', 'VirtualRide', 'VirtualRow', 'VirtualRun', 'VirtualSki', 'WaterSport', 'Wheelchair', 'Windsurf', 'Workout', 'Yoga', 'Other']):
                raise ValueError("each list item must be one of ('Ride', 'Run', 'Swim', 'WeightTraining', 'Hike', 'Walk', 'AlpineSki', 'BackcountrySki', 'Badminton', 'Canoeing', 'Crossfit', 'EBikeRide', 'EMountainBikeRide', 'Elliptical', 'Golf', 'GravelRide', 'TrackRide', 'Handcycle', 'HighIntensityIntervalTraining', 'Hockey', 'IceSkate', 'InlineSkate', 'Kayaking', 'Kitesurf', 'MountainBikeRide', 'NordicSki', 'OpenWaterSwim', 'Padel', 'Pilates', 'Pickleball', 'Racquetball', 'Rugby', 'RockClimbing', 'RollerSki', 'Rowing', 'Sail', 'Skateboard', 'Snowboard', 'Snowshoe', 'Soccer', 'Squash', 'StairStepper', 'StandUpPaddling', 'Surfing', 'TableTennis', 'Tennis', 'TrailRun', 'Transition', 'Velomobile', 'VirtualRide', 'VirtualRow', 'VirtualRun', 'VirtualSki', 'WaterSport', 'Wheelchair', 'Windsurf', 'Workout', 'Yoga', 'Other')")
        return value

    @field_validator('hr_load_type')
    def hr_load_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['AVG_HR', 'HR_ZONES', 'HRSS']):
            raise ValueError("must be one of enum values ('AVG_HR', 'HR_ZONES', 'HRSS')")
        return value

    @field_validator('pace_units')
    def pace_units_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SECS_100M', 'SECS_100Y', 'MINS_KM', 'MINS_MILE', 'SECS_500M', 'SECS_400M', 'SECS_250M']):
            raise ValueError("must be one of enum values ('SECS_100M', 'SECS_100Y', 'MINS_KM', 'MINS_MILE', 'SECS_500M', 'SECS_400M', 'SECS_250M')")
        return value

    @field_validator('pace_load_type')
    def pace_load_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SWIM', 'RUN']):
            raise ValueError("must be one of enum values ('SWIM', 'RUN')")
        return value

    @field_validator('gap_model')
    def gap_model_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NONE', 'STRAVA_RUN']):
            raise ValueError("must be one of enum values ('NONE', 'STRAVA_RUN')")
        return value

    @field_validator('elevation_correction')
    def elevation_correction_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NO', 'AUTO', 'YES']):
            raise ValueError("must be one of enum values ('NO', 'AUTO', 'YES')")
        return value

    @field_validator('load_order')
    def load_order_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['POWER_HR_PACE', 'POWER_PACE_HR', 'HR_POWER_PACE', 'HR_PACE_POWER', 'PACE_POWER_HR', 'PACE_HR_POWER']):
            raise ValueError("must be one of enum values ('POWER_HR_PACE', 'POWER_PACE_HR', 'HR_POWER_PACE', 'HR_PACE_POWER', 'PACE_POWER_HR', 'PACE_HR_POWER')")
        return value

    @field_validator('tiz_order')
    def tiz_order_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['POWER_HR_PACE', 'POWER_PACE_HR', 'HR_POWER_PACE', 'HR_PACE_POWER', 'PACE_POWER_HR', 'PACE_HR_POWER']):
            raise ValueError("must be one of enum values ('POWER_HR_PACE', 'POWER_PACE_HR', 'HR_POWER_PACE', 'HR_PACE_POWER', 'PACE_POWER_HR', 'PACE_HR_POWER')")
        return value

    @field_validator('workout_order')
    def workout_order_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['POWER_HR_PACE', 'POWER_PACE_HR', 'HR_POWER_PACE', 'HR_PACE_POWER', 'PACE_POWER_HR', 'PACE_HR_POWER']):
            raise ValueError("must be one of enum values ('POWER_HR_PACE', 'POWER_PACE_HR', 'HR_POWER_PACE', 'HR_PACE_POWER', 'PACE_POWER_HR', 'PACE_HR_POWER')")
        return value

    @field_validator('interval_display')
    def interval_display_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['POWER_HR_PACE', 'POWER_PACE_HR', 'HR_POWER_PACE', 'HR_PACE_POWER', 'PACE_POWER_HR', 'PACE_HR_POWER']):
            raise ValueError("must be one of enum values ('POWER_HR_PACE', 'POWER_PACE_HR', 'HR_POWER_PACE', 'HR_PACE_POWER', 'PACE_POWER_HR', 'PACE_HR_POWER')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SportSettings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of mmp_model
        if self.mmp_model:
            _dict['mmp_model'] = self.mmp_model.to_dict()
        # override the default output from pydantic by calling `to_dict()` of display
        if self.display:
            _dict['display'] = self.display.to_dict()
        # override the default output from pydantic by calling `to_dict()` of activity_charts
        if self.activity_charts:
            _dict['activity_charts'] = self.activity_charts.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SportSettings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "athlete_id": obj.get("athlete_id"),
            "types": obj.get("types"),
            "warmup_time": obj.get("warmup_time"),
            "cooldown_time": obj.get("cooldown_time"),
            "ftp": obj.get("ftp"),
            "indoor_ftp": obj.get("indoor_ftp"),
            "w_prime": obj.get("w_prime"),
            "p_max": obj.get("p_max"),
            "power_zones": obj.get("power_zones"),
            "sweet_spot_min": obj.get("sweet_spot_min"),
            "sweet_spot_max": obj.get("sweet_spot_max"),
            "power_spike_threshold": obj.get("power_spike_threshold"),
            "power_zone_names": obj.get("power_zone_names"),
            "ftp_est_min_secs": obj.get("ftp_est_min_secs"),
            "use_laps_for_power_intervals": obj.get("use_laps_for_power_intervals"),
            "keep_all_laps_for_power_intervals": obj.get("keep_all_laps_for_power_intervals"),
            "after_kj0": obj.get("after_kj0"),
            "after_kj1": obj.get("after_kj1"),
            "power_field": obj.get("power_field"),
            "lthr": obj.get("lthr"),
            "max_hr": obj.get("max_hr"),
            "hr_zones": obj.get("hr_zones"),
            "hr_zone_names": obj.get("hr_zone_names"),
            "hr_load_type": obj.get("hr_load_type"),
            "hrrc_min_percent": obj.get("hrrc_min_percent"),
            "threshold_pace": obj.get("threshold_pace"),
            "pace_units": obj.get("pace_units"),
            "pace_zones": obj.get("pace_zones"),
            "pace_zone_names": obj.get("pace_zone_names"),
            "pace_load_type": obj.get("pace_load_type"),
            "gap_model": obj.get("gap_model"),
            "elevation_correction": obj.get("elevation_correction"),
            "use_gap_zone_times": obj.get("use_gap_zone_times"),
            "best_effort_distances": obj.get("best_effort_distances"),
            "pace_curve_start": obj.get("pace_curve_start"),
            "load_order": obj.get("load_order"),
            "tiz_order": obj.get("tiz_order"),
            "workout_order": obj.get("workout_order"),
            "interval_display": obj.get("interval_display"),
            "default_gear_id": obj.get("default_gear_id"),
            "default_indoor_gear_id": obj.get("default_indoor_gear_id"),
            "extract_workouts": obj.get("extract_workouts"),
            "show_pauses": obj.get("show_pauses"),
            "ignore_velocity": obj.get("ignore_velocity"),
            "default_workout_time": obj.get("default_workout_time"),
            "created": obj.get("created"),
            "updated": obj.get("updated"),
            "mmp_model": PowerModel.from_dict(obj["mmp_model"]) if obj.get("mmp_model") is not None else None,
            "display": Display.from_dict(obj["display"]) if obj.get("display") is not None else None,
            "activity_field_ids": obj.get("activity_field_ids"),
            "activity_charts": ActivityCharts.from_dict(obj["activity_charts"]) if obj.get("activity_charts") is not None else None,
            "custom_field_ids": obj.get("custom_field_ids"),
            "custom_field_values": obj.get("custom_field_values"),
            "custom_zones_ids": obj.get("custom_zones_ids"),
            "other": obj.get("other"),
            "iseFTPSupported": obj.get("iseFTPSupported"),
            "use_distance_for_intervals": obj.get("use_distance_for_intervals")
        })
        return _obj


